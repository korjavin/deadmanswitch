name: CI

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'

    - name: Build
      run: go build -v ./...

    - name: Test with coverage
      run: |
        go test -v -race -coverprofile=coverage.txt -covermode=atomic ./...
        go tool cover -func=coverage.txt

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.txt
        fail_ci_if_error: false

    - name: Build Docker image
      run: |
        docker build -t ghcr.io/korjavin/deadmanswitch:${{ github.sha }} .
        docker tag ghcr.io/korjavin/deadmanswitch:${{ github.sha }} ghcr.io/korjavin/deadmanswitch:latest

    - name: Login to GitHub Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v2
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Push Docker image
      if: github.event_name != 'pull_request'
      run: |
        docker push ghcr.io/korjavin/deadmanswitch:${{ github.sha }}
        docker push ghcr.io/korjavin/deadmanswitch:latest

  frontend-tests:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Build application for testing
      run: |
        docker build -t deadmanswitch_deadmanswitch:test .

    - name: Run frontend tests
      run: |
        # Set CI environment variable
        export CI=true

        # Create a network for the containers
        docker network create deadmanswitch_default || true

        # Start the application with the test database
        export TEST_RUN_ID=$(date +%s)
        docker-compose -f docker-compose.yml -f tests/frontend/docker-compose.test.yml up -d

        # Wait for the application to start
        echo "Waiting for application to start..."
        MAX_WAIT=120
        COUNTER=0

        while [ $COUNTER -lt $MAX_WAIT ]; do
          # Check if container is running
          if ! docker ps | grep -q deadmanswitch_deadmanswitch; then
            echo "Container is not running! Checking logs..."
            docker logs deadmanswitch_deadmanswitch_1 || true
            echo "Trying to restart container..."
            docker-compose up -d
            sleep 5
          fi

          # Try to connect to the application
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8082/login || echo "000")
          if [ "$STATUS" = "200" ]; then
            echo "Application is ready!"
            break
          fi

          COUNTER=$((COUNTER+1))
          echo "Waiting for application to start... ($((MAX_WAIT-COUNTER)) seconds left)"

          # Print more detailed status every 10 seconds
          if [ $((COUNTER % 10)) -eq 0 ]; then
            echo "Current container status:"
            docker ps
            echo "Checking container logs (last 10 lines):"
            docker logs --tail=10 deadmanswitch_deadmanswitch_1 || true
          fi

          sleep 1
        done

        # Check if we timed out
        if [ $COUNTER -eq $MAX_WAIT ]; then
          echo "Timed out waiting for application to start"
          docker logs deadmanswitch_deadmanswitch_1 || true
          docker ps
          exit 1
        fi

        # Run the tests using the Playwright Docker image
        docker run --rm --network host -v $(pwd):/app -w /app mcr.microsoft.com/playwright:v1.42.0-jammy /bin/bash -c "cd /app/tests/frontend && npm install && npx playwright test"
        TEST_EXIT_CODE=$?

        # Stop the containers
        docker-compose down

        exit $TEST_EXIT_CODE
